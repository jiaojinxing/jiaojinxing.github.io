<html>
<head>
<!-- Copyright 1997,1998, The Open Group, All Rights Reserved -->
<!-- Generated by The Open Group's  RHTM tool v1.2.1 -->

<title>Data Size Neutrality and 64-bit Support </title>
<BODY BGCOLOR=#FFFFFFFF">
<basefont size=3>
<h2>Data Size Neutrality and 64-bit Support</h2>
<p>
The Single UNIX Specification, Version 2 provides enhanced support for 64-bit programming models
by being n-bit clean and data size neutral.
This article is a brief introduction to 64-bit programming models,
data size neutrality, and application porting issues.
<h3>Introduction</h3>
<p>
When the UNIX operating system was first created in 1969 it was
developed to run on a 16-bit computer architecture.
The C language of the time supported 16-bit integer and pointer data
types and also supported a 32-bit integer data type that could be
emulated on hardware which did not support 32-bit arithmetic operations.
<p>
When 32-bit computer architectures, which supported 32-bit
integer arithmetic operators and 32-bit pointers, were introduced
in the late 1970s, the UNIX operating system was quickly ported to this new
class of hardware platforms.
The C language data model developed to support these 32-bit architectures
quickly evolved to consist of a 16-bit short-integer type,
a 32-bit integer type, and a 32-bit pointer.
During the 1980s, this was the predominant C data model available
for 32-bit UNIX platforms.
<p>
To describe these two data models in modern terms, the 16-bit UNIX
platforms used an IP16 data model, while 32-bit UNIX platforms use the
ILP32 programming model.
The notation describes the width assigned to the basic data types;
for example, ILP32 denotes that
<B>int</B>
(I),
<B>long</B>
(L), and
<B>pointer</B>
(P) types are all 32-bit entities.
This notation is used extensively throughout this article.
<p>
The first UNIX standardization effort was begun in 1983 by
a /usr/group committee.
This work was merged into the work program of the IEEE POSIX committee
in 1985.
By 1988, both POSIX and X/Open committees had developed detailed
standards and specifications that were based upon the predominant
UNIX implementations of the time.
These committees endeavored to develop architecture-neutral definitions
that could be implemented on any hardware architecture.
<p>
The transition from 16-bit to 32-bit processor architectures happened
quite rapidly just before the UNIX standardization work was begun.
Since the specifications were based on existing practice and the
predominant data model did not change during this gestation period,
some dependencies upon the ILP32 data model were inadvertently
incorporated into the final specifications.
<p>
Most of today's 32-bit UNIX platforms use the ILP32 data model.
However another data model, the LP32 model, is also very popular
for other operating systems.
The majority of C-language programs written for Microsoft Windows 3.1
are written for the Win-16 API which uses the LP32 data model.
The Apple Macintosh also uses the LP32 data model.
<p>
32-bit platforms have a number of limitations which are increasingly
a source of frustration to developers of large applications, such as
databases, who wish to take advantage of advances in computer hardware.
There is much discussion today in the computer industry about the
barrier presented by 32-bit addresses.
32-bit pointers can only address 4GB of virtual address space.
There are ways of overcoming this limitation, but application development
is more complicated and performance is significantly reduced.
Until recently the size of a data file could not exceed 4GB.
However, the 4GB file size limitation was overcome by the Large
File Summit extensions which are included in XSH, Issue&nbsp;5.
<p>
Disk storage has been improving in real density at the rate of
70% compounded annually, and drives of 12GB and larger are readily available.
Memory prices have not dropped as sharply, but 64MB chips are
readily available, with larger chips in active development.
CPU processing power continues to increase by about 50% every 18 months,
providing the power to process ever larger quantities of data.
This conjunction of technological forces, along with the continued
demand for systems capable of supporting ever larger databases and
simulation models and full-motion video, have generated requirements for
support of larger addressing structures.
<p>
A number of 64-bit processors are now available, and the transition
from 32-bit to 64-bit architectures is rapidly occurring amongst
all the major hardware vendors.
64-bit UNIX platforms do not suffer from the file size or flat
address space limitations of 32-bit platforms.
Applications can access files that occupy terabytes of disk space
because 64-bit file offsets are possible.
Similarly, applications can now theoretically access terabytes of
memory because pointers can be 64 bits.
More physical memory results in faster operations.
The performance of memory-mapped file access, caching, and swapping,
is greatly improved.
64-bit virtual addresses simplify the design of large applications.
All the major database vendors now support 64-bit platforms because
of dramatically improved performance for very large database
applications available on very large memory (VLM) systems.
<p>
The world is currently dominated by 32-bit computers, a situation that
is likely to continue to exist for the near future.
These computers run 16 or 32-bit applications or some mixture of the two.
Meanwhile, 64-bit computers will run 32-bit code, 64-bit code, or
mixtures of the two (and perhaps even some 16-bit code).
New 64-bit applications and operating systems must integrate smoothly
into this environment.
Key issues facing the computing industry are the interchange of
data between 64 and 32-bit systems (in some cases on the same system)
and the cost of maintaining software in both environments.
Such interchange is especially needed for large application suites
such as database systems, where one may want to distribute
most of the applications as 32-bit binaries that run across a large
installed base, but be able to choose 64-bits for a few crucial applications.
<h3>64-bit Data Models</h3>
<p>
Prior to the introduction of 64-bit platforms, it was generally
believed that the introduction of 64-bit UNIX operating systems would
naturally use the ILP64 data model.
However, this view was too simplistic and overlooked optimizations
that could be obtained by choosing a different data model.
<p>
Unfortunately, the C programming language does not provide a mechanism
for adding new fundamental data types.
Thus, providing 64-bit addressing and integer arithmetic capabilities
involves changing the bindings or mappings of the existing data types
or adding new data types to the language.
<p>
ISO/IEC&nbsp;9899:1990, Programming Languages - C (ISO C) left the definition of the
<B>short int</B>,
the
<B>int</B>,
the
<B>long int</B>,
and the
<B>pointer</B>
deliberately vague to avoid artificially constraining hardware
architectures that might benefit from defining these data types
independent from the other.
The only constraints were that
<B>int</B>s
must be no smaller than
<B>short</B>s,
and
<B>long</B>s
must be no smaller than
<B>int</B>s,
and
<B>size_t</B>
must represent the largest unsigned type supported by an implementation.
It is possible, for instance, to define a
<B>short</B>
as 16 bits, an
<B>int</B>
as 32 bits, a
<B>long</B>
as 64 bits and a
<B>pointer</B>
as 128 bits.
The relationship between the fundamental data types can be expressed as:
<p>

<I>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) = sizeof(size_t)</I>

<p>
Ignoring non-standard types, all three of the following
64-bit pointer data models satisfy the above relationship:
<ul>
<p>
<li>
LP64 (also known as 4/8/8)
<p>
<li>
ILP64 (also known as 8/8/8)
<p>
<li>
LLP64 (also known as 4/4/8).
<p>
</ul>
<p>
The differences between the three models lies in the non-pointer
data types.
The table below details the data types for the above three data models
and includes LP32 and ILP32 for comparison purposes.
<pre>
<P><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center>&nbsp;<b>Data Type</b>
<th align=center>&nbsp;<b>LP32</b>
<th align=center>&nbsp;<b>ILP32</b>
<th align=center>&nbsp;<b>ILP64</b>
<th align=center>&nbsp;<b>LLP64</b>
<th align=center>&nbsp;<b>LP64</b>
<tr valign=top><td align=left>&nbsp;<b>char</b>
<td align=left>&nbsp;8
<td align=left>&nbsp;8
<td align=left>&nbsp;8
<td align=left>&nbsp;8
<td align=left>&nbsp;8
<tr valign=top><td align=left>&nbsp;<b>short</b>
<td align=left>&nbsp;16
<td align=left>&nbsp;16
<td align=left>&nbsp;16
<td align=left>&nbsp;16
<td align=left>&nbsp;16
<tr valign=top><td align=left>&nbsp;<b>int32</b>
<td align=left>&nbsp;
<td align=left>&nbsp;
<td align=left>&nbsp;32
<td align=left>&nbsp;
<td align=left>&nbsp;
<tr valign=top><td align=left>&nbsp;<b>int</b>
<td align=left>&nbsp;16
<td align=left>&nbsp;32
<td align=left>&nbsp;64
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<tr valign=top><td align=left>&nbsp;<b>long</b>
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<td align=left>&nbsp;64
<td align=left>&nbsp;32
<td align=left>&nbsp;64
<tr valign=top><td align=left>&nbsp;<b>long long (int64)</b>
<td align=left>&nbsp;
<td align=left>&nbsp;
<td align=left>&nbsp;
<td align=left>&nbsp;64
<td align=left>&nbsp;
<tr valign=top><td align=left>&nbsp;<b>pointer</b>
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<td align=left>&nbsp;64
<td align=left>&nbsp;64
<td align=left>&nbsp;64
</table>
</pre>
<p>
When the width of one or more of the C data types is changed,
applications may be affected in various ways.
These effects fall into two main categories:
<ul>
<p>
<li>
Data objects, such as a structure, defined with one of the 64-bit
data types will be different in size from those declared in
an identical way on a 16 or 32-bit system.
<p>
<li>
Common assumptions about the relationships between the fundamental
data types may no longer be valid in a 64-bit data model.
Applications which depend on those relationships often cease to work
properly when compiled on a 64-bit platform.
A typical assumption made by many application developers is that:
<p>
<I>sizeof(int) = sizeof(long) = sizeof(pointer)</I>
<p>
This relationship is not codified in any C programming standard, but it
is valid for the ILP32 data model.
However, it is not valid for two of the three 64-bit data models
described above, nor is it valid for the LP32 data model.
<p>
</ul>
<p>
The ILP64 data model attempts to maintain the relationship between
<B>int</B>,
<B>long</B>,
and
<B>pointer</B>
which exists in the ILP32 model by making all three types the same size.
Assignment of a pointer to an
<B>int</B>
or a
<B>long</B>
will not result in data loss.
<p>
The downside of this model is that it depends on the addition of a
new 32-bit data type such as
<B>int32</B>
to handle true 32-bit quantities.
There is thus a potential for conflict with existing
<B>typedef</B>s
in applications.
An application which was developed on an ILP32 platform, and
subsequently ported to an ILP64 platform, may be forced to make
frequent use of the
<B>int32</B>
data type to preserve the size and alignment of data because of
interoperability requirements or binary compatibility with
existing data files.
<p>
The LLP64 data model preserves the relationship between
<B>int</B>
and
<B>long</B>
by leaving both as 32-bit types.
Data objects, such as structures, which do not contain pointers will
be the same size as on a 32-bit system.
This model is sometimes described as a 32-bit model with 64-bit addresses.
Most of the run-time problems associated with the assumptions between
the sizes of the data types are related to the assumption that a
pointer will fit in an
<B>int</B>.
To solve this class of problems,
<B>int</B>
or
<B>long</B>
variables which should be 64-bits in length are changed to
<B>long long</B>
(or
<B>int64</B>),
a non-standard data type.
This data model is thus again dependent on the introduction of a new
data type.
Again there is potential for conflict with existing
<B>typedef</B>s
in applications.
<p>
The LP64 data model takes the middle road.
8, 16, and 32-bit scalar types (
<B>char</B>,
<B>short</B>,
and
<B>int</B>)
are provided to support objects that must maintain size and
alignment with 32-bit systems.
A 64-bit type,
<B>long</B>,
is provided to support the full arithmetic capabilities, and is
available to use in conjunction with pointer arithmetic.
Applications that assign addresses to scalar objects need to specify
the object as
<B>long</B>
instead of
<B>int</B>.
<p>
In the LP64 data model, data types are natural.
Each scalar type is larger than the preceding type.
No new data types are required.
As a language design issue, the purpose of having
<B>long</B>
in the language anticipates cases where there is an integral type
longer than
<B>int</B>.
The fact that
<B>int</B>
and
<B>long</B>
represent different width data types is a natural and common sense
approach, and is the standard in the PC world where
<B>int</B>
is 16-bits and
<B>long</B>
is 32-bits.
<p>
A major test for any C data model is its ability to
support the very large existing UNIX applications code base.
The investment in code, experience, and data surrounding these
applications is the largest determiner of the rate at which new
technology is adopted and spread.
In addition, it must be easy for an application developer to
build code which can be used in both existing and new environments.
<p>
The UNIX development community is driven technically by a set
of API agreements embodied in standards and specifications documents
from groups such as X/Open, IEEE, ANSI, and ISO.
These documents were developed over many years to codify existing
practice and define agreement on new capabilities.
As a result these specifications are of major value to the system
developers, application developers, and end-users.
There are numerous test suites which verify that implementations correctly
embody the details of a specification and certify that fact to
interested parties.
Any 64-bit data model cannot invalidate large portions of these
specifications and expect to achieve wide adoption.
<p>
A number of vendors have extensive experience with the LP64 data model.
By far, the largest body of existing 32-bit code already modified
for 64-bit environments runs on LP64 platforms.
Experience has shown that it is relatively easy to modify existing
code so that it can be compiled on either an 32-bit or 64-bit platform.
Interoperability with existing ILP32 platforms is well proven and
is not an issue.
At least one LP64-based operating system (Digital UNIX V4.0)
has met and passed the majority of existing verification suites and
has obtained the UNIX&nbsp;95 brand.
<p>
A small number of ILP64-based platforms have also shipped.
These have demonstrated that it is feasible to complete the
implementation of an ILP64 environment.
However, as of early 1997, no LLP64 or ILP64-based systems have
achieved the same level of standards conformance or met the
requirements of the UNIX&nbsp;95 brand.
<p>
Although the number of applications written in C requiring a large
virtual address space is growing rapidly, there has not been
a requirement to date for a 64-bit
<B>int</B>
data type.
The majority of existing 64-bit applications previously ran only
on 32-bit platforms, and had no expectation of a greater range for the
<B>int</B>
data type.
The extra 32 bits of data space in a 64-bit
<B>int</B>
would appear to be wasted.
Any future applications which require a larger scalar data type can
use the
<B>long</B>
type.
<p>
Nearly all applications moving from a 32-bit platform require some
minor modifications to handle 64-bit pointers, especially where
erroneous assumptions about the relative size of
<B>int</B>
and
<B>pointer</B>
data types were made.
Common assumptions about the relative sizes of
<B>int</B>,
<B>char</B>,
<B>short</B>,
and
<B>float</B>
data types generally do not cause problems on LP64 platforms
(since the sizes of those data types are identical to those on an
ILP32 platform), but do so on an ILP64 platform.
<p>
Other language implementations will continue to support a 32-bit
<B>int</B>
type.
For example, the FORTRAN-77 standard requires that the type INTEGER
be the same size as REAL, which is half the size of DOUBLE PRECISION.
This, together with customer expectations, means that FORTRAN-77
implementations will generally leave INTEGER as a 32-bit type,
even on 64-bit platforms.
A significant number of applications use C and FORTRAN together,
either calling each other or sharing data files.
Such applications have been amongst the first to move to 64-bit
environments.
Experience has shown that it is usually easier to modify the data
sizes and types on the C side than the FORTRAN side of such applications.
These applications will continue to require a 32-bit
<B>int</B>
data type in C regardless of the size of the
<B>int</B>
data type.
<p>
In 1995, a number of major UNIX vendors agreed to standardize on the
LP64 data model for a number of reasons:
<ul>
<p>
<li>
Experience suggests that neither the LP64 nor the ILP64 data models
provide a painless porting path from a 32-bit platform, but that
all other things being equal, the smaller data types in the LP64 data
model enable better application performance.
<p>
<li>
A crucial investment for end-users is the existing data built up
over decades in their computer systems.
Any proposed solution must make it easy to utilize such data on
a continuing basis.
Unfortunately, the ILP64 data model does not provide a natural way
to describe 32-bit data types, and must resort to non-portable
constructs such as
<B>int32</B>
to describe such types.
This is likely to cause practical problems in producing code which
can run on both 32 and 64-bit platforms without numerous
<B>#ifdef</B>
constructions.
It has been possible to port large quantities of code to LP64 platforms
without the need to make such changes, while maintaining the investment
made in data sets, even in cases where the typing information was
not made externally visible by the application.
<p>
<li>
Most
<B>int</B>s
in existing applications can remain as 32 bits in a
64-bit environment; only a small number are expected to be the same size as
<B>pointer</B>
or
<B>long</B>.
Under the ILP64 data model, most
<B>int</B>s
will need to change to
<B>int32</B>.
However,
<B>int32</B>
does not behave like a 32-bit
<B>int</B>.
Instead,
<B>int32</B>
is like
<B>short</B>
in that all operations have to be converted to
<B>int</B>
(64-bits, sign extended) and performed in 64-bit arithmetic.
Thus,
<B>int32</B>
in the ILP64 data model is not exactly the same as
<B>int</B>
in the ILP32 data model.
These differences may cause subtle and hard-to-find bugs.
<p>
<li>
Instruction cycle penalties are incurred whenever additional cycles
are required to properly implement the semantics of the intended data model.
For example, in the LP64 data model it is only necessary to perform
sign extension on
<B>int</B>
when you have a mixed expression including
<B>long</B>s.
However, most integral expressions do not include
<B>long</B>s
and compilers can be made smart enough to only sign extend when necessary.
<p>
<li>
<B>int</B>
is by far the most frequent data type to be found (statically
and sometimes dynamically) within C and C++ programs.
64-bit integers require twice as much space as 32-bit integers.
Applications using 64-bit integers consume additional memory and
CPU cycles transporting that memory throughout the system.
Furthermore, the latency penalty of 64-bit integers can be enormous,
especially to disk, where it can exceed 1,000,000 CPU cycles
(3 nsec to 3 msec).
The memory size penalty for unneeded 64-bit integers could therefore
be very high for some applications.
<p>
<li>
Portability, especially for combined FORTRAN and C applications,
is enhanced by the LP64 data model, and the most common types of
problems that can occur are susceptible to automatic detection.
<p>
<li>
Interoperability is improved by the ability to use a standard
data type to declare data structures that can be used in both
32-bit and 64-bit environments.
<p>
<li>
Standards conformance has been demonstrated both in the practical
sense by the porting of many programs and in the formal sense
of compliance with industry standards through verification test suites.
<p>
<li>
Transition from the current industry practice is smooth and
direct following a path grooved with experience and demonstrated success.
<p>
<li>
No new non-portable data types are required.
The data model makes natural use of the C fundamental data types.
<p>
</ul>
<h3>Data Size Neutrality</h3>
<p>
When it was understood that the Single UNIX Specification was constraining system implementations
that were other than ILP32, the relevant specifications were
reviewed and recommendations drafted to make these specifications
data size- and architecture-neutral.
These recommendations were incorporated into the Single UNIX Specification, Version 2 published in 1997.
<p>
The following is a summary of the changes that were made.
Changes are identified with respect to the CAE Specifications which
made up the previous version of the Single UNIX Specification.
<h4>System Interface Definitions, Issue 5 (XBD)</h4>
<p>
The following text was added to System Interface Definitions, Issue 4, Version 2 (XBD), Chapter 10, page 130,
point 6, as a fourth bullet item:
<pre>
<dl compact><dt> <dd>
&quot;Ranges greater than those listed here are allowed.&quot;
</dl>
</pre>
<p>
This section describes the argument syntax of the standard
utilities and introduces terminology used throughout the Single UNIX Specification
for describing the arguments processed by the utilities.
It was updated so that the maximum value of a numerical argument
is allowed to be greater than a 32-bit value, thus permitting support
of 64-bit values.
<h4>System Interfaces and Headers, Issue 5 (XSH)</h4>
<p>
Two general changes were made to System Interfaces and Headers, Issue 4, Version 2 (XSH):
<ul>
<p>
<li>
Use of the type
<B>int</B>
for return values, arguments, and structure members.
<p>
Several functions using the type
<B>int</B>
for return values, arguments, or structure members are not able
to represent 64-bit values correctly on architectures implementing
an LP64 data model.
Where alternate functions were available which do not have this
limitation, the functions were marked LEGACY and the alternate functions
noted in the Application Usage section.
Where no alternative function was available, the types were changed
in a data model-neutral manner to overcome this limitation.
<p>
<li>
<B>size_t</B>
<I>versus</I>
<B>ssize_t</B>.
<p>
Several functions have a parameter declared to be
<B>size_t</B>
where the parameter specifies the length of an object to manipulate,
and returns the portion of the length of the object processed in a type
<B>ssize_t</B>.
The type
<B>ssize_t</B>
is required so that a negative return value can be used to
indicate an error.
However, in these functions it is possible for the return value to
exceed the range of the type
<B>ssize_t</B>
(since
<B>size_t</B>
has a larger range of positive values than
<B>ssize_t</B>).
Some functions, such as
<I>mq_receive()</I> ,
<I>msgrcv()</I> ,
<I>read()</I> ,
<I>strfmon()</I> ,
and
<I>write()</I> ,
resolve this conflict by restricting the object size in the description
section.
For example, the description section for the
<I>rea()</I>d
function states: "If the value of
<I>nbyte</I>
is greater than {SSIZE_MAX}, the result is implementation-dependent."
<p>
</ul>
<p>
The following were the detailed changes:
<ul>
<p>
<li>
<I>getdtablesize()</I>
<p>
The
<I>getdtablesize()</I>
function returns the size of the file descriptor table.
This is equivalent to
<I>getrlimit()</I>
with the RLIMIT_NOFILE option.
Whereas the
<I>getrlimit()</I>
function returns a value of type
<B>rlim_t</B>.
This function, returning an
<B>int</B>,
may have problems representing appropriate values in the future.
A note about this was added to the Application Usage section,
and the function marked LEGACY, with the recommendation that applications
should use the
<I>getrlimit()</I>
function instead.
<p>
<li>
<I>getpagesize()</I>
<p>
The
<I>getpagesize()</I>
function returns the current page size.
It is equivalent to
<I>sysconf</I>(_SC_PAGE_SIZE) and
<I>sysconf</I>(_SC_PAGESIZE).
This function, returning an
<B>int</B>,
may have problems representing appropriate values on non-32-bit platforms.
Also, the behavior is not specified for this function on systems
that support variable size pages.
On variable page size systems, a page can be extremely large
(theoretically, up to the size of memory).
This allows very efficient address translations for large segments
of memory that have common page attributes.
A note about this has been added to the Application Usage section,
and the function marked LEGACY, with the recommendation that
applications should use the
<I>sysconf()</I>
function instead.
<p>
<li>
<I>readlink()</I>
<p>
The
<I>readlink()</I>
function returns the size of the information that it reads as a type
<B>int</B>,
but the size of the buffer area is specified by a
<B>size_t</B>.
This function is specified in the IEEE PASC P1003.1a draft standard,
and the return value may change in a future version of the
Single UNIX Specification to reflect the final POSIX.1a standard.
<p>
<li>
<I>sbrk()</I>
<p>
The parameter to the
<I>sbrk()</I>
function is a type
<B>int</B>
defining the number of bytes by which to change the break value.
This function may not be able to address the full memory range
in the future for certain data models.
A new type has been introduced to be used in place of the type
<B>int</B>.
This is the
<B>intptr_t</B>
type which is an abstract data type equating
to a signed integral type large enough to hold any pointer.
This new type is one of a new set of types introduced in a new header
<I>inttypes.h</I>
to address the issues of data sizes for specific types.
<p>
<li>
<I>inttypes.h</I>
<p>
The
<I>inttypes.h</I>
header is a new header in the Single UNIX Specification, Version 2 and includes definitions for
at least the following types:
<dl compact>
<p>
<dt><B>int16_t</B><dd>16-bit signed integral type.
<p>
<dt><B>int32_t</B><dd>32-bit signed integral type.
<p>
<dt><B>int64_t</B><dd>64-bit signed integral type.
<p>
<dt><B>uint16_t</B><dd>16-bit unsigned integral type.
<p>
<dt><B>uint32_t</B><dd>32-bit unsigned integral type.
<p>
<dt><B>uint64_t</B><dd>64-bit unsigned integral type.
<p>
<dt><B>intptr_t</B><dd>Signed integral type large enough to hold any pointer.
<p>
<dt><B>uintptr_t</B><dd>Unsigned integral type large enough to hold any pointer.
<p>
</dl>
<p>
<li>
<I>sys/shm.h</I>
<p>
The element
<I>shm_segsz</I>
of structure
<B>shmid_ds</B>,
specifying the size of a memory segment was of type
<B>int</B>.
This has been changed to type
<B>size_t</B>.
<p>
<li>
<I>sys/stat.h</I>
and
<I>sys/statvfs.h</I>
<p>
The element
<I>st_blocks</I>
of the structure
<B>stat</B>
was changed to the new abstract
<B>blkcnt_t</B>
type.
<p>
The elements
<I>f_blocks</I>,
<I>f_bfree</I>,
and
<I>f_bavail</I>
of the structure
<B>statvfs</B>
were changed to the new abstract
<B>fsblkcnt_t</B>
type.
<p>
The elements
<I>f_files</I>,
<I>f_ffree</I>,
and
<I>f_favail</I>
of the structure
<B>statvfs</B>
were changed to the new abstract
<B>fsfilcnt_t</B>
type.
<p>
To support the above changes, the following definitions were added to
<I>sys/types.h</I> :
<dl compact>
<p>
<dt><B>blkcnt_t</B><dd>A signed arithmetic type, used for file block counts.
<p>
<dt><B>fsblkcnt_t</B><dd>An arithmetic type, used for filesystem block counts.
<p>
<dt><B>fsfilcnt_t</B><dd>An arithmetic type, used for file serial numbers.
<p>
</dl>
<p>
<li>
<I>sys/time.h</I>
<p>
The
<I>tv_usec</I>
element of the
<B>timeval</B>
structure was of type
<B>long</B>.
This has been changed to use a new abstract data type for signed
integral time values, known as
<B>suseconds_t</B>.
<B>suseconds_t</B>
was added to
<I> sys/types.h</I> .
<p>
<li>
<I>msgrcv()</I>
<p>
In XSH, Issue&nbsp;4, Version&nbsp;2,
<I>msgrcv()</I>
returns the size of the message received as an integer value, but
the size of the message area is specified by a
<B>size_t</B>.
On 64-bit systems where
<B>size_t</B>
may be a different data type to
<B>int</B>,
this will cause problems.
XSH, Issue&nbsp;5 addresses this problem by changing the type of the
return value from
<B>int</B>
to
<B>ssize_t</B>,
and adding a warning to the Description about values of
<I>msgsz</I>
larger the {SSIZE_MAX}.
<p>
<li>
<I>sysconf()</I>
and
<I>unistd.h</I>
<p>
There is now a way to find out the data model supported by the platform.
This can be queried at compile time, using the constants defined in
<I>unistd.h</I> ,
or at run time using the
<I>sysconf()</I>
function.
<p>
The following symbolic constants are defined to have the value -1
if the implementation never provides the feature, and to have
a value other than -1 if the implementation always provides the
feature.
If these are undefined, the
<I>sysconf()</I>
function can be used to determine whether the feature is provided for a
particular invocation of the application.
<dl compact>
<p>
<dt>_XBS5_ILP32_OFF32<dd>Implementation provides a C-language compilation environment with 32-bit
<B>int</B>,
<B>long</B>,
<B>pointer</B>,
and
<B>off_t</B>
types.
<p>
<dt>_XBS5_ILP32_OFFBIG<dd>Implementation provides a C-language compilation environment with
32-bit
<B>int</B>,
<B>long</B>,
and
<B>pointer</B>
types, and an
<B>off_t</B>
type using at least 64 bits.
<p>
<dt>_XBS5_LP64_OFF64<dd>Implementation provides a C-language compilation environment with
32-bit
<B>int</B>
and 64-bit
<B>long</B>,
<B>pointer</B>,
and
<B>off_t</B>
types.
<p>
<dt>_XBS5_LPBIG_OFFBIG<dd>Implementation provides a C-language compilation environment with an
<B>int</B>
type using at least 32 bits and
<B>long</B>,
<B>pointer</B>,
and
<B>off_t</B>
types, using at least 64 bits.
<p>
</dl>
<p>
</ul>
<h4>Commands and Utilities, Issue 5 (XCU)</h4>
<p>
A new section of text was added to the end of the first paragraph of
Section 1.9, Utility Description Defaults, to align with requirements
in POSIX.2, and restates that integer variables and constants
used by utilities are permitted to be 64-bit values.
<h5>Programming Environments</h5>
<p>
The
<I>c89</I>
reference page has some new text describing programming environments.
All conforming implementations must support one of the following
programming environments by default.
Applications can use the
<I>sysconf()</I>
function or the
<I>getconf</I>
utility to determine which programming
environments the implementation supports.
<p>
The following table describes the supported programming environments.
<pre>
<P><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center>&nbsp;<b>Programming Environment</b>
<th align=center>&nbsp;<b>int</b>
<th align=center>&nbsp;<b>long</b>
<th align=center>&nbsp;<b>pointer</b>
<th align=center>&nbsp;<b>off_t</b>
<tr valign=top><td align=left>&nbsp;XBS5_ILP32_OFF32
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<tr valign=top><td align=left>&nbsp;XBS5_ILP32_OFFBIG
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<td align=left>&nbsp;32
<td align=left>&nbsp;&gt;=64
<tr valign=top><td align=left>&nbsp;XBS5_LP64_OFF64
<td align=left>&nbsp;32
<td align=left>&nbsp;64
<td align=left>&nbsp;64
<td align=left>&nbsp;64
<tr valign=top><td align=left>&nbsp;XBS5_LPBIG_OFFBIG
<td align=left>&nbsp;&gt;= 32
<td align=left>&nbsp;&gt;= 64
<td align=left>&nbsp;&gt;= 64
<td align=left>&nbsp;&gt;= 64
</table>
</pre>
<p>
The
<I>c89</I>
reference page also has text describing new support in
<I>getconf</I>
and
<I>sysconf()</I>
to determine configuration strings for C compiler flags,
linker/loader flags, and libraries for each supported environment.
<p>
When an application wishes to use a specific programming environment
rather than an implementation's default programming environment
while compiling, the application must first verify that the
implementation supports the desired environment.
If the desired programming environment is supported, the application
can then invoke
<I>c89</I>
with the appropriate C compiler flags as the
first options for the compile, the appropriate linker/loader flags
after any other options but before any operands, and the
appropriate libraries at the end of the operands.
<p>
The following table shows the various options available:
<pre>
<P><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center>&nbsp;<b>Programming Environment</b>
<th align=center>&nbsp;<b>Use</b>
<th align=center>&nbsp;<b>Compiler Flags</b>
<tr valign=top><td align=left>&nbsp;XBS5_ILP32_OFF32
<td align=left>&nbsp;C Compiler Flags
<td align=left>&nbsp;XBS5_ILP32_OFF32_CFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Linker/Loader Flags
<td align=left>&nbsp;XBS5_ILP32_OFF32_LDFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Libraries Flags
<td align=left>&nbsp;XBS5_ILP32_OFF32_LIBS
<tr valign=top><td align=left>&nbsp;XBS5_ILP32_OFFBIG
<td align=left>&nbsp;C Compiler Flags
<td align=left>&nbsp;XBS5_ILP32_OFFBIG_CFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Linker/Loader Flags
<td align=left>&nbsp;XBS5_ILP32_OFFBIG_LDFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Libraries Flags
<td align=left>&nbsp;XBS5_ILP32_OFFBIG_LIBS
<tr valign=top><td align=left>&nbsp;XBS5_LP64_OFF64
<td align=left>&nbsp;C Compiler Flags
<td align=left>&nbsp;XBS5_LP64_OFF64_CFLAG
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Linker/Loader Flags
<td align=left>&nbsp;XBS5_LP64_OFF64_LDFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Libraries Flags
<td align=left>&nbsp;XBS5_LP64_OFF64_LIBS
<tr valign=top><td align=left>&nbsp;XBS5_LPBIG_OFFBIG
<td align=left>&nbsp;C Compiler Flags
<td align=left>&nbsp;XBS5_LPBIG_OFFBIG_CFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Linker/Loader Flags
<td align=left>&nbsp;XBS5_LPBIG_OFFBIG_LDFLAGS
<tr valign=top><td align=left>&nbsp;
<td align=left>&nbsp;Libraries Flags
<td align=left>&nbsp;XBS5_LPBIG_OFFBIG_LIBS
</table>
</pre>
<h3>Porting Issues</h3>
<p>
Porting an application to a 64-bit UNIX system can be accomplished
with a minimal amount of effort if the application was developed
using good modern software engineering practices such as:
<ul>
<p>
<li>
ISO&nbsp;C function prototypes
<p>
<li>
consistent and careful use of data types
<p>
<li>
all declarations are in headers.
<p>
</ul>
<p>
First of all, determine which data model is available on the platform
you are porting to.
The data model you are porting to will have a major impact
on the amount of work required to achieve a successful port.
<p>
Then take the time to create and use ISO&nbsp;C function prototypes
if they are absent from the source code.
Unfortunately large quantities of perfectly good legacy code
developed in the days before portability was a major issue
may not have function prototypes.
Fortunately many compilers have an option to generate ISO&nbsp;C function
prototypes.
<p>
The remainder of this article assumes that you are porting to an
LP64 platform since this is the data model of choice amongst major
vendors, but the issues raised are equally valid on some or all
of the other 64-bit data models.
<h4>General</h4>
<p>
Use utilities such as
<I>grep</I>
to locate and check all instances of the following:
<ul>
<p>
<li>
Shift and complement operators; that is, &quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;, &quot;~&quot;.
If used with
<B>long</B>,<B>&quot;.</B>
add &quot;L&quot; to value shifted to avoid an incorrect result.
<p>
<li>
Addresses of &quot;&amp;&quot;.
Make sure they are not being stored in an
<B>int</B>.
<p>
<li>
Declarations of type
<B>long</B>.
Many of these can be converted to type
<B>int</B>
to save space.
This is particularly true for network code.
<p>
<li>
The functions
<I>lseek()</I> ,
<I>fseek()</I> ,
<I>ftell()</I> ,
<I>fgetpos()</I> ,
and so on.
Use either
<B>off_t</B>
or
<B>fpos_t</B>
as appropriate for offset arguments.
Do not use
<B>int</B>
or
<B>long</B>
to store file offsets.
<p>
<li>
All (
<B>int *</B>)
and (
<B>long *</B>)
casts.
<p>
<li>
Use of (
<B>char *</B>)
0 for zero or (
<B>char *</B>)
comparisons.
Use NULL instead.
<p>
<li>
Hard-coded byte counts or memory sizes.
These will be wrong if they assume
<B>long</B>s
or
<B>pointer</B>s
are 32 bits.
Applications should use the
<I>sizeof()</I>
operator to avoid such problems.
<p>
</ul>
<h4>Declarations</h4>
<p>
To enable application code to work on both 32-bit and 64-bit platforms,
check all
<B>int</B>
and
<B>long</B>
declarations.
Declare integer constants using &quot;L&quot; or &quot;U&quot; as appropriate.
Ensure an
<B>unsigned int</B>
is used where appropriate to prevent sign extension.
If you have specific variables that need to be 32 bits on both
platforms, define the type to be
<B>int</B>.
If the variable should be 32 bits on an ILP32 platform and 64 bits on
an LP64 platform, define the variables to be
<B>long</B>.
<p>
Declare numeric variables as
<B>int</B>
or
<B>long</B>
for alignment and performance.
Don't worry about trying to save bytes by using
<B>char</B>
or
<B>short</B>.
Remember that if the type specifier is missing from a declaration,
it defaults to an
<B>int</B>.
Declare character pointers and character bytes as
<B>unsigned</B>
to avoid sign extension problems with 8-bit characters.
<h4>Assignments and Function Parameters</h4>
<p>
All assignments require checking.
Since
<B>pointer</B>,
<B>int</B>,
and
<B>long</B>
are no longer the same size on LP64 platforms, problems may arise
depending on how the variables are assigned and used within
an application.
<p>
Do not use
<B>int</B>
and
<B>long</B>
interchangeably because of the possible truncation of significant
digits, as shown in the following example:
<pre>

<I>int iv;
long lv;
iv = lv;</I>

</pre>
<p>
Do not use
<B>int</B>
to store a pointer.
The following example works on an ILP32 platform but fails on an LP64
platform because a 32-bit integer cannot hold a 64-bit pointer:
<pre>

<I>unsigned int i, *p;
<p>
i = (unsigned) p;</I>

</pre>
<p>
The converse of the above example is sign extension:
<pre>

<I>int *p;
int i;
<p>
p = (int *)i;</I>

</pre>
<p>
Do not pass
<B>long</B>
arguments to functions expecting
<B>int</B>
arguments.
Avoid assignments similar to the following:
<pre>

<I>int foo(int);
<p>
int iv;
long lv;
iv = foo( lv );</I>

</pre>
<p>
Do not freely exchange
<B>pointer</B>s
and
<B>int</B>s.
Assigning a pointer to an
<B>int</B>,
assigning back to a
<B>pointer</B>,
and dereferencing the pointer may result in a segmentation fault.
Avoid assignments similar to the following example:
<pre>

<I>int iv;
char *buffer;
<p>
buffer = (char *) malloc((size_t)MAX_LINE);
<p>
iv = (int) buffer;
buffer = (char *) iv;</I>

</pre>
<p>
Do not pass a pointer to a function expecting an
<B>int</B>
as this will result in lost information.
For example, avoid assignments similar to the following:
<pre>

<I>void f();
char *cp;
<p>
f(cp);</I>

</pre>
<p>
Use of ISO&nbsp;C function prototypes should avoid this problem.
Use the
<B>void*</B>
type if you need to use a generic pointer type.
This is preferable to converting a
<B>pointer</B>
to type
<B>long</B>.
<p>
Examine all assignments of a
<B>long</B>
to a
<B>double</B>
as this can result in a loss of accuracy.
On an ILP32 platform, an application can assume that a
<B>double</B>
contains an exact representation of any value stored in a
<B>long</B>
(or a
<B>pointer</B>).
On LP64 platforms this is no longer a valid assumption.
<h4>External Interfaces</h4>
<p>
An external interface mismatch occurs when an external interface
requires data in a particular size or layout, but the data is not
supplied in the correct format.
<p>
For example, an external interface may expect a 64-bit quantity,
but receive instead a 32-bit quantity.
Another example is an external structure which expects a
pointer to a structure with 2
<B>int</B>s
(8 bytes) but instead receives a pointer to a structure with an
<B>int</B>
and a
<B>long</B>
(16 bytes, 12 of data, 4 of alignment padding).
External interface mismatching is a major cause of porting problems.
<h4>Format Strings</h4>
<p>
The function
<I>printf()</I>
and related functions can be a major source of problems.
For example, on 32-bit platforms, using &quot;%d&quot; to print either an
<B>int</B>
or
<B>long</B>
will usually work,
but on LP64 platforms &quot;%ld&quot; must be used to print a
<B>long</B>.
Use the modifier &quot;l&quot; with the d, u, o, and x conversion characters
to specify assignment of type
<B>long</B>
or
<B>unsigned long</B>.
When printing a pointer, use &quot;%p&quot;.
If you wish to print the pointer as a specific representation,
the pointer should be cast to an appropriate integer type before using
the desired format specifier.
For example, to print a pointer as a
<B>unsigned long</B>
decimal number, use %lu:
<p>
<I>char *p;</I>
<p>
<I>printf( "%p %lu\n", (void *)p, (unsigned long)p );</I>
<p>
As a rule, to print an integer of arbitrary size, cast the integer to
<B>long</B>
or
<B>unsigned long</B>
and use the &quot;%ld&quot; conversion character.
<h4>Constants</h4>
<p>
The results of arithmetic operations on a 64-bit platform can differ
from those obtained using the same code on a 32-bit platform.
Differing results are often caused by sign extension problems.
These are generally the result of mixing
<B>signed</B>
and
<B>unsigned</B>
types and the use of hexadecimal constants.
Consider the following code example:
<pre>

<I>long lv = 0xFFFFFFFF;
<p>
if ( lv &lt; 0 ) {</I>

</pre>
On an ILP32 platform,
<I>lv</I>
is interpreted as -1 and the
<I>if</I>
condition succeeds.
On an LP64 platform
<I>lv</I>
is interpreted as 4294967295 and the if condition fails.
<h4>Pointers</h4>
<p>
On ILP32 platforms, an
<B>int</B>
and a
<B>pointer</B>
are the same size (32 bits) and application code can generally use
them interchangeably.
For example, a structure could contain a field declared as an
<B>int</B>,
and most of the time contain an
<B>integer</B>,
but occasionally be used to store a
<B>pointer</B>.
<p>
Another example, which most 32-bit
<B>int</B>
utilities will not catch, is the following:
<pre>

<I>int iv, *pv;
<p>
iv = (int) pv;
pv = (int *) iv;</I>

</pre>
<p>
This code fails on an LP64 platform.
Not only do you lose the high 4 bytes of &quot;p&quot;, but by default these high
bytes are significant.
<h4>Sizeof()</h4>
<p>
On ILP32 platforms
<B>sizeof</B>(<B>int</B>)
=
<B>sizeof</B>(<B>long</B>)
=
<B>sizeof</B>(<B>ptr *</B>).
Using the wrong
<I>sizeof()</I>
operand does not cause a problem.
On LP64 platforms, however, using the wrong
<I>sizeof()</I>
will almost certainly cause a problem.
For example, the following 32-bit code which copies an array of
<B>pointer</B>s
to
<B>int</B>s:
<p>
<I>memcpy((char *)dest, (char *)src, number * sizeof(int))</I>
<p>
must be changed to use
<B>sizeof</B>(<B>int *</B>):
<p>
<I>memcpy((char *)dest, (char *)src, number * sizeof(int *))</I>
<p>
on an LP64 platform.
<p>
Note that the result of the
<I>sizeof()</I>
operation is type
<B>size_t</B>
which is an
<B>unsigned long</B>
on LP64 platforms.
<h4>Structures and Unions</h4>
<p>
The size of structures and unions on 64-bit platforms can be different
from those on 32-bit platforms.
For example, on ILP32 platforms the size of the following
structure is 8 bytes:
<pre>

<I>struct Node {
    struct Node *left;
    struct Node *right;
}</I>

</pre>
<p>
but on an LP64 platform its size is 16 bytes.
<p>
If you are sharing data defined in structures between 32-bit
and 64-bit platforms, be careful about using
<B>long</B>s
and
<B>pointer</B>s
as members of shared structures.
These data types introduce sizes that are not generally available on
32-bit platforms.
Avoid storing structures with pointers in data files.
This code then becomes non-portable between 32-bit and 64-bit platforms.
<p>
To increase the portability of your code, use
<B>typedef</B>'d
types for the fields in structures to set up the types as
appropriate for the platform, and use the
<I>sizeof()</I>
operator to determine the size of a structure.
If necessary, use the
<B>#pragma</B>
pack statement to avoid compiler structure padding.
[<small><B>Note:</B>This is not portable and is not a general solution.
</small>]
This is important if data alignment cannot change (network packets,
and so on).
<p>
Structures are aligned according to the strictest aligned member.
Padding may be added to ensure proper alignment.
This padding may be added within the structure, or at the end
of the structure to terminate the structure on the same
alignment boundary which it started.
<p>
Problems can occur when the use of a union is based on an implicit
assumption, such as the size of member types.
<p>
Consider the following code fragment which works on ILP32 platforms.
The code assumes that an array of two
<B>unsigned long</B>
overlays a double.
<pre>

<I>union double_union {
    double d;
    unsigned long ul[2];
};</I>

</pre>
<p>
To work on an LP64 platform,
<I>ul</I>
must be changed to an
<B>unsigned int</B>
type:
<pre>

<I>union double_union {
    double d;
    unsigned int ul[2]
};</I>

</pre>
This problem also occurs when building unions between
<B>int</B>s
and
<B>pointer</B>s
since they are not the same size on LP64 platforms.
<p>
Beware of all aliasing which is different multiple definitions of
the same data.
For example, assume the following two structures refer to the same
data in different ways:
<pre>

<I>struct node {
    int src_addr, dst_addr;
    char *name;
}
<p>
struct node {
    struct node *src, *dst;
    char *name;
}</I>
</pre>

<p>
This works on an ILP32 platform, but fails on an LP64 platform.
The two structure definitions should be replaced with a union
declaration to ensure portability.

<h3>More Information</h3>
<p>
This article is derived from The Open Group Source Book,
"Go Solo 2 - The Authorized Guide to Version 2 
of the Single UNIX Specification". This
is published herein with permission of The Open Group.
More information on the Single UNIX Specification, Version 2
can be obtained from the following sources:
<ul>
<p>
<li>
The online version of the Single UNIX Specification can be
found at the
URL 
<a href="http://www.UNIX-systems.org/online.html">http://www.UNIX-systems.org/online.html</a>.
<p>
<li>
The Open Group Source Book "Go Solo 2 - The Authorized Guide to Version 2 
of the Single UNIX Specification", 600 pages, ISBN 0-13-575689-8. This
book provides complete information on what's new in Version 2 , with
technical papers written by members of the working groups
that developed the specifications , and a 
CD-ROM containing the complete 3000 page specification in both HTML
and PDF formats (including PDF reader software). 
For more information on the book, see URL 
<a href="http://www.unix-systems.org/gosolo2">http://www.UNIX-systems.org/gosolo2</a> .
<p>
<li>
Additional information on the Single UNIX Specification can be
obtained at The Open Group world wide web site, see the URL
<a href="http://www.UNIX-systems.org/">http://www.UNIX-systems.org</a> . 
<p>
</ul>
<p>
<HR>
<FONT  SIZE=2 FACE="ARIAL">
<P>
<em>UNIX is a registered trademark of The Open Group</em>.
<P>
Copyright &copy; 1997-1999 , The Open Group.
</CENTER>
</FONT>
</BODY>
</HTMl>

